[
    {
        "question": "L03 D01: La formula riportata in figura è:",
        "image": "",
        "optionA": "Nessuna delle altre risposte",
        "optionB": "Soddisfacibile",
        "optionC": "Logicamente valida",
        "optionD": "Non soddisfacibile",
        "optionE": "",
        "optionF": "",
        "correct": "optionD",
        "explanation": "La formula afferma che per ogni X, p(X) è vero se e solo se p(X) è falso. Questo è un controsenso logico perché un'affermazione e la sua negazione non possono essere vere contemporaneamente. Di conseguenza, non esiste alcuna interpretazione in cui questa formula possa essere vera, rendendola non soddisfacibile."
    },
    {
        "question": "L03 D02: Quali delle formule riportate in figura sono formule ben formate?",
        "image": "",
        "optionA": "3, 5",
        "optionB": "1, 2, 3",
        "optionC": "2, 3",
        "optionD": "Tutte",
        "optionE": "",
        "optionF": "",
        "correct": "optionA",
        "explanation": "Le formule 3 e 5 sono sintatticamente corrette. La formula 3 utilizza correttamente il quantificatore esistenziale con un predicato, e la formula 5 utilizza correttamente il bicondizionale tra due predicati. Le altre formule sono incomplete o mancano di componenti necessarie per essere ben formate."
    },
    {
        "question": "L03 D03: La formula riportata in figura è:",
        "image": "",
        "optionA": "Soddisfacibile",
        "optionB": "Non soddisfacibile",
        "optionC": "Nessuna delle altre risposte",
        "optionD": "Logicamente valida",
        "optionE": "",
        "optionF": "",
        "correct": "optionD",
        "explanation": "Questa formula afferma che se per ogni X, p(X) è vero, allora p(X) è vero per ogni X specifico. Questa è una tautologia perché l'ipotesi (tutte le X soddisfano p) implica logicamente la conclusione (una X specifica soddisfa p). Di conseguenza, la formula è vera in tutte le interpretazioni possibili, rendendola logicamente valida."
    },
    {
        "question": "L03 D04: Le regole che permettono di costruire formule ben formate nella logica dei predicati del primo ordine sono prescritte:",
        "image": "",
        "optionA": "dalla grammatica",
        "optionB": "dalla sintassi",
        "optionC": "dalla semantica",
        "optionD": "dalla sintassi e dalla semantica",
        "optionE": "",
        "optionF": "",
        "correct": "optionD",
        "explanation": "Nella logica dei predicati del primo ordine, la sintassi determina le regole per costruire formule grammaticalmente corrette, definendo quali combinazioni di simboli sono permesse. La semantica, d'altra parte, assegna un significato a queste formule ben formate, specificando le condizioni sotto le quali una formula è considerata vera. Entrambi gli aspetti sono cruciali per la formulazione corretta delle espressioni logiche."
    },
    {
        "question": "L03 D05: La formula riportata in figura è:",
        "image": "",
        "optionA": "Soddisfacibile",
        "optionB": "Non soddisfacibile",
        "optionC": "Logicamente valida",
        "optionD": "Nessuna delle altre risposte",
        "optionE": "",
        "optionF": "",
        "correct": "optionA",
        "explanation": "La formula afferma che per ogni X, p(X) è vero, o non è vero che d(X). Questa formula è soddisfacibile perché esistono interpretazioni in cui questa può essere vera. Ad esempio, se d(X) è falso in generale, allora la formula è vera indipendentemente dal valore di verità di p(X)."
    },
    {
        "question": "L03 D06: Qual è il significato intuitivo che daremmo alla formula riportata in figura?",
        "image": "",
        "optionA": "Esiste uno studente che ha un tutor",
        "optionB": "Ogni studente ha un tutor",
        "optionC": "Esiste un tutor che fa tutoraggio a tutti gli studenti",
        "optionD": "Ogni tutor ha uno studente",
        "optionE": "",
        "optionF": "",
        "correct": "optionB",
        "explanation": "La formula usa un quantificatore universale seguito da un quantificatore esistenziale, indicando che per ogni studente esiste almeno un tutor tale che la relazione 'tutoraggio' sia vera tra quel tutor e lo studente. Quindi, intuitivamente significa che ogni studente ha almeno un tutor."
    },
    {
        "question": "L03 D07: Quali delle formule riportate in figura sono formule ben formate?",
        "image": "",
        "optionA": "2, 3, 5",
        "optionB": "1, 2, 3",
        "optionC": "1, 2, 5",
        "optionD": "Tutte",
        "optionE": "",
        "optionF": "",
        "correct": "optionC",
        "explanation": "Le formule 1, 2 e 5 sono sintatticamente corrette. Formula 1, nonostante le molte parentesi, è corretta. Formula 2 è una corretta implicazione, e Formula 5 rappresenta una negazione corretta di un quantificatore esistenziale."
    },
    {
        "question": "L03 D08: Assumendo che l'insieme delle costanti sia {a, b, c} ed un'interpretazione I renda veri gli atomi p(a) e p(b), quali delle seguenti formule sono vere rispetto ad I?",
        "image": "",
        "optionA": "1, 2, 4",
        "optionB": "3",
        "optionC": "1, 4",
        "optionD": "3, 4",
        "optionE": "",
        "optionF": "",
        "correct": "optionB",
        "explanation": "La formula 3, ∀X p(X), afferma che p(X) è vero per ogni X nel dominio specificato. Dato che p(a) e p(b) sono veri e l'interpretazione non menziona p(c) come falso, assumendo che p(c) possa essere vero rende questa formula vera nel contesto dato. Le altre formule non sono garantite essere vere con le informazioni fornite."
    },
    {
        "question": "L04 D01: Una teoria assiomatica è corretta se...",
        "image": "",
        "optionA": "ogni fbf conseguenza logica dei suoi assiomi è derivabile dalla teoria",
        "optionB": "almeno una fbf della teoria è sintatticamente corretta",
        "optionC": "ogni fbf della teoria è sintatticamente corretta",
        "optionD": "ogni fbf derivabile dalla teoria è conseguenza logica dei suoi assiomi",
        "optionE": "",
        "optionF": "",
        "correct": "optionD",
        "explanation": "Una teoria assiomatica è considerata corretta quando tutte le formule ben formate (fbf) che possono essere derivate dagli assiomi (cioè, che sono dimostrabili come teoremi all'interno della teoria) sono effettivamente vere sotto gli assiomi stessi. Questo assicura che le inferenze fatte all'interno del sistema siano valide e che la teoria non produca risultati falsi a partire da verità assunte."
    },
    {
        "question": "L04 D02: Una teoria assiomatica è completa se...",
        "image": "",
        "optionA": "almeno una fbf della teoria è sintatticamente corretta",
        "optionB": "ogni fbf conseguenza logica dei suoi assiomi è derivabile dalla teoria",
        "optionC": "ogni fbf derivabile dalla teoria è conseguenza logica dei suoi assiomi",
        "optionD": "ogni fbf della teoria è sintatticamente corretta",
        "optionE": "",
        "optionF": "",
        "correct": "optionB",
        "explanation": "Una teoria è completa quando ogni verità logica che può essere implicata dagli assiomi (cioè, ogni conseguenza logica degli assiomi) può essere formalmente derivata utilizzando le regole di inferenza della teoria. Questo significa che il sistema assiomatico è sufficientemente robusto per catturare tutte le verità che gli assiomi implicano, non lasciando alcuna verità 'fuori' dal raggiungimento attraverso deduzione formale."
    },
    {
        "question": "L04 D03: Quali fra le seguenti regole di inferenza rende una teoria assiomatica non corretta?",
        "image": "",
        "optionA": "Abduzione",
        "optionB": "Modus Tollens",
        "optionC": "Modus Ponens",
        "optionD": "Deduzione",
        "optionE": "",
        "optionF": "",
        "correct": "optionA",
        "explanation": "L'abduzione è una forma di inferenza che permette di derivare una possibile causa data una conseguenza osservata. Sebbene possa essere utile in contesti come la diagnosi, non garantisce la veridicità delle conclusioni in un contesto logico formale, poiché altre cause potrebbero essere responsabili dell'osservazione, rendendo così la teoria potenzialmente non corretta."
    },
    {
        "question": "L04 D04: Applicando il Modus Tollens...",
        "image": "",
        "optionA": "da A -> B e ~A deriviamo ~B",
        "optionB": "da A -> B e ~B deriviamo ~A",
        "optionC": "da A -> B e ~B deriviamo A",
        "optionD": "da A -> B e B deriviamo A",
        "optionE": "",
        "optionF": "",
        "correct": "optionB",
        "explanation": "Il Modus Tollens è una regola di inferenza che afferma che se abbiamo una implicazione (A -> B) e la negazione del conseguente (~B), allora possiamo logicamente concludere la negazione dell'antecedente (~A). Questo ci permette di dedurre che se 'se A allora B' è vero e 'B non è vero', allora 'A non è vero' deve essere anch'esso vero."
    },
    {
        "question": "L04 D05: Applicando l'Abduzione...",
        "image": "",
        "optionA": "da A -> B e B deriviamo A",
        "optionB": "da A -> B e ~B deriviamo A",
        "optionC": "da A -> B e ~B deriviamo ~A",
        "optionD": "da ~A -> ~B e ~A deriviamo ~B",
        "optionE": "",
        "optionF": "",
        "correct": "optionA",
        "explanation": "L'abduzione permette di ipotizzare una possibile causa dato un effetto osservato. Se sappiamo che 'se A allora B' è vero e osserviamo che B è vero, allora possiamo ragionevolmente ipotizzare che A sia stato il causante, anche se questa inferenza non garantisce la certezza assoluta di A, poiché altre cause potrebbero altresì spiegare B."
    },
    {
        "question": "L04 D06: Supponiamo che un insieme di fbf F sia stato trasformato in un insieme F' di clausole. Quale delle seguenti affermazioni è vera?",
        "image": "",
        "optionA": "F' implica logicamente F",
        "optionB": "F implica logicamente F'",
        "optionC": "F è non soddisfacibile se e solo se F' è non soddisfacibile",
        "optionD": "F ed F' sono logicamente equivalenti",
        "optionE": "",
        "optionF": "",
        "correct": "optionC",
        "explanation": "La trasformazione di un insieme di formule ben formate in un insieme di clausole mantiene la proprietà di insoddisfacibilità. Questo significa che se l'originale insieme di fbf non può essere soddisfatto (ovvero, non esiste alcuna interpretazione che le renda tutte vere contemporaneamente), lo stesso vale per l'insieme trasformato di clausole. Questa proprietà è fondamentale per il principio di risoluzione e altri metodi di inferenza basati sulla forma clausale."
    },
    {
        "question": "L04 D07: Applicando il Modus Tollens...",
        "image": "",
        "optionA": "da -A -> -B e -A deriviamo -B",
        "optionB": "da A -> B e -B deriviamo -A",
        "optionC": "da A -> B e -B deriviamo A",
        "optionD": "da A -> B e B deriviamo A",
        "optionE": "",
        "optionF": "",
        "correct": "optionB",
        "explanation": "Il Modus Tollens è una regola di inferenza logica che dice: se abbiamo un'implicazione A -> B e sappiamo che B non è vero (-B), possiamo concludere che anche A non deve essere vero (-A). Questo segue dalla logica che se A fosse vero, allora B dovrebbe necessariamente essere vero, contraddicendo l'osservazione che B non è vero."
    },
    {
        "question": "L04 D08: Applicando l'Abduzione...",
        "image": "",
        "optionA": "da A -> B e B deriviamo A",
        "optionB": "da A -> B e -B deriviamo A",
        "optionC": "da A -> B e -B deriviamo -A",
        "optionD": "da -A -> -B e -A deriviamo -B",
        "optionE": "",
        "optionF": "",
        "correct": "optionA",
        "explanation": "L'abduzione permette di proporre una possibile spiegazione (A) per un'osservazione (B), partendo dall'ipotesi che se A causa B (A -> B) e B è osservato, allora A potrebbe essere la spiegazione. Questo tipo di inferenza non garantisce che A sia vero in assoluto, poiché altre cause potrebbero altrettanto generare B, ma è una forma comune di ragionamento usato in diagnosi e scienze."
    },
    {
        "question": "L05 D01: L'algoritmo SLD è:",
        "image": "",
        "optionA": "Corretto ma non completo per insiemi di clausole di Horn",
        "optionB": "Completo ma non corretto per insiemi di clausole",
        "optionC": "Corretto e completo per insiemi di clausole",
        "optionD": "Corretto e completo per insiemi di clausole di Horn",
        "optionE": "",
        "optionF": "",
        "correct": "optionD",
        "explanation": "L'algoritmo SLD è specificamente efficace con insiemi di clausole di Horn, dove è sia corretto (derivazioni corrette da premesse vere) sia completo (capace di derivare tutte le conclusioni vere dalle premesse)."
    },
    {
        "question": "L05 D02: Ad ogni passo, l'algoritmo SLD:",
        "image": "",
        "optionA": "non seleziona alcuna clausola dall'insieme base",
        "optionB": "seleziona due clausole dall'insieme base",
        "optionC": "seleziona una delle clausole dall'insieme base",
        "optionD": "seleziona tutte le clausole dall'insieme base",
        "optionE": "",
        "optionF": "",
        "correct": "optionC",
        "explanation": "L'algoritmo SLD seleziona strategicamente una clausola dall'insieme base a ogni passo del processo di risoluzione, facilitando una gestione più efficiente e mirata del processo inferenziale."
    },
    {
        "question": "L05 D03: Si considerino le sostituzioni s1 = {X/Y, K/L} e s2 = {Y/a, L/K}. La combinazione di s1 e s2 delle due sostituzioni è:",
        "image": "",
        "optionA": "(X/a, K/L)",
        "optionB": "(X/a, K/K)",
        "optionC": "(X/a, L/K)",
        "optionD": "(X/a)",
        "optionE": "",
        "optionF": "",
        "correct": "optionD",
        "explanation": "Combinando le sostituzioni s1 e s2, ogni occorrenza di Y in s1 viene sostituita con 'a' da s2, e L viene sostituito con K, che a sua volta viene sostituito da L. La sostituzione risultante per X è 'a'."
    },
    {
        "question": "L05 D04: Applicando la risoluzione alle clausole a v -b e a v b v -c otteniamo:",
        "image": "",
        "optionA": "a v -b",
        "optionB": "-a v b",
        "optionC": "La clausola vuota",
        "optionD": "-a v -b",
        "optionE": "",
        "optionF": "",
        "correct": "optionA",
        "explanation": "Nel processo di risoluzione non troviamo letterali complementari che permettono di eliminare entrambi i letterali (b e -b) dalle due clausole, quindi la risoluzione non modifica la clausola a v -b."
    },
    {
        "question": "L05 D05: Sia F un insieme di clausole e -t una clausola. Se applicando la risoluzione ad F ∪ {-t} non deriviamo la clausola vuota significa che:",
        "image": "",
        "optionA": "F non implica logicamente t",
        "optionB": "F implica logicamente t",
        "optionC": "F è soddisfacibile",
        "optionD": "F è insoddisfacibile",
        "optionE": "",
        "optionF": "",
        "correct": "optionA",
        "explanation": "Se aggiungiamo -t a F e non riusciamo a derivare la clausola vuota, significa che non possiamo dimostrare che F implica t, indicando che non c'è contraddizione con l'aggiunta di -t, quindi F non implica t logicamente."
    },
    {
        "question": "L05 D06: Se deriviamo la clausola vuota applicando il principio di risoluzione ad un insieme di clausole F significa che:",
        "image": "",
        "optionA": "F è insoddisfacibile",
        "optionB": "F è vuoto",
        "optionC": "F è logicamente valido",
        "optionD": "F è soddisfacibile",
        "optionE": "",
        "optionF": "",
        "correct": "optionC",
        "explanation": "Derivare la clausola vuota dall'insieme di clausole F indica che F è insoddisfacibile, ovvero non esiste alcun assegnamento che possa rendere tutte le clausole in F simultaneamente vere, implicando che F è una tautologia o logicamente valido."
    },
    {
        "question": "L05 D07: Quando trasformiamo un insieme S di fbf in un insieme S' di clausole...",
        "image": "",
        "optionA": "S' è insoddisfacibile",
        "optionB": "S è insoddisfacibile",
        "optionC": "S è insoddisfacibile se e solo se S' è insoddisfacibile",
        "optionD": "S ed S' sono logicamente equivalenti",
        "optionE": "",
        "optionF": "",
        "correct": "optionC",
        "explanation": "La trasformazione di un insieme S di fbf in clausole S' preserva la proprietà di insoddisfacibilità, significando che S è insoddisfacibile se e solo se anche S' è insoddisfacibile."
    },
    {
        "question": "L05 D08: Su quale proprietà si basano i sistemi a refutazione?",
        "image": "",
        "optionA": "F ⊨ t se e solo se F ∪ {t} è insoddisfacibile",
        "optionB": "F ⊨ t se e solo se F ∪ {¬t} è insoddisfacibile",
        "optionC": "F ⊨ t se e solo se F ∪ {t} è soddisfacibile",
        "optionD": "F ⊨ t se e solo se F ∪ {t} è logicamente valida",
        "optionE": "",
        "optionF": "",
        "correct": "optionB",
        "explanation": "I sistemi a refutazione operano sulla base che una formula t è una conseguenza logica di un insieme di formule F se e solo se l'aggiunta della negazione di t all'insieme F conduce a una contraddizione (rendendo l'insieme insoddisfacibile). Questo approccio è utilizzato per verificare logicamente la validità di una proposizione attraverso la ricerca di contraddizioni."
    },
    {
        "question": "Un funtore è:",
        "image": "",
        "optionA": "Un simbolo di funzione",
        "optionB": "Un simbolo di predicato",
        "optionC": "Un simbolo di predicato o un simbolo di funzione",
        "optionD": "Una variabile",
        "optionE": "",
        "optionF": "",
        "correct": "optionC",
        "explanation": "In Prolog, un funtore può essere sia un simbolo di predicato che di funzione. Serve come identificatore per funzioni o predicati."
    },
    {
        "question": "In Prolog, un placeholder è utilizzato:",
        "image": "",
        "optionA": "Al posto di una costante che compare una sola volta in un atomo del corpo di una regola",
        "optionB": "Al posto di una variabile che compare una sola volta nella testa di una regola",
        "optionC": "Al posto di una variabile che compare una sola volta in un atomo del corpo di una regola",
        "optionD": "Al posto di una costante che compare una sola volta nella testa di una regola",
        "optionE": "",
        "optionF": "",
        "correct": "optionC",
        "explanation": "Il placeholder '_', rappresenta una variabile anonima in Prolog, usata quando la variabile è irrilevante oltre il suo primo utilizzo nel corpo della regola."
    },
    {
        "question": "Quali dei seguenti termini è una lista?",
        "image": "",
        "optionA": "lista(X, Y, Z)",
        "optionB": "lista(1,2,3)",
        "optionC": "lista([1,2,3])",
        "optionD": "[]",
        "optionE": "",
        "optionF": "",
        "correct": "optionD",
        "explanation": "In Prolog, le liste sono rappresentate da termini racchiusi tra parentesi quadre. '[]' è una rappresentazione di una lista vuota."
    },
    {
        "question": "Quali sei seguenti termini è una lista?",
        "image": "",
        "optionA": "lista(X, Y, Z)",
        "optionB": "lista(1,2,3)",
        "optionC": "lista([1,2,3])",
        "optionD": "[1,[1,2]]",
        "optionE": "",
        "optionF": "",
        "correct": "optionD",
        "explanation": "In Prolog, le liste sono rappresentate da termini racchiusi tra parentesi quadre e possono includere altri termini, inclusi altri elenchi, come elementi. '[1,[1,2]]' è conforme alla sintassi delle liste in Prolog."
    },
    {
        "question": "Quale dei seguenti oggetti è una costante?",
        "image": "",
        "optionA": "X",
        "optionB": "'x'",
        "optionC": "Costante",
        "optionD": "Y",
        "optionE": "",
        "optionF": "",
        "correct": "optionB",
        "explanation": "In Prolog, le costanti sono rappresentate da identificatori che iniziano con una lettera minuscola o sono delimitati da apici singoli. 'x' con apici è interpretato come una costante."
    },
    {
        "question": "Quale dei seguenti oggetti è una variabile?",
        "image": "",
        "optionA": "0",
        "optionB": "Costante",
        "optionC": "x",
        "optionD": "'x'",
        "optionE": "",
        "optionF": "",
        "correct": "optionC",
        "explanation": "In Prolog, le variabili sono identificate da un nome che inizia con una lettera maiuscola o un trattino basso (underscore). 'x' inizia con una lettera minuscola e viene trattata come variabile."
    },
    {
        "question": "Quale dei seguenti oggetti è un placeholder?",
        "image": "",
        "optionA": "'-'",
        "optionB": "Placeholder",
        "optionC": "0",
        "optionD": "_",
        "optionE": "",
        "optionF": "",
        "correct": "optionD",
        "explanation": "In Prolog, il simbolo '_' è utilizzato come placeholder per indicare una variabile anonima che non necessita di essere identificata oltre il suo uso specifico nella regola o nella query."
    },
    {
        "question": "Quale comando comunica a Prolog di continuare la ricerca di nuovi valori che sostituiscano le variabili del goal lo rendano vero?",
        "image": "",
        "optionA": "':'",
        "optionB": "'.'",
        "optionC": "';'",
        "optionD": "'-'",
        "optionE": "",
        "optionF": "",
        "correct": "optionC",
        "explanation": "In Prolog, il simbolo ';' viene utilizzato dall'utente durante una query interattiva per richiedere al sistema di continuare la ricerca di altre soluzioni possibili dopo che una soluzione è stata trovata."
    },
    {
        "question": "L07 D01: La valutazione del goal 'X is 1 + 2' restituisce l'output:",
        "image": "",
        "optionA": "false",
        "optionB": "X = 1 + 2",
        "optionC": "X = 3",
        "optionD": "true",
        "optionE": "",
        "optionF": "",
        "correct": "optionC",
        "explanation": "In Prolog, l'operatore 'is' viene utilizzato per valutare espressioni aritmetiche e assegnare il risultato alla variabile a sinistra. L'espressione '1 + 2' viene calcolata come 3, quindi 'X is 1 + 2' assegna a X il valore 3."
    },
    {
        "question": "L07 D02: Per esprimere la condizione di uguaglianza si utilizza l'operatore:",
        "image": "",
        "optionA": "~",
        "optionB": "=",
        "optionC": "==",
        "optionD": "is",
        "optionE": "",
        "optionF": "",
        "correct": "optionC",
        "explanation": "In Prolog, '==' è l'operatore utilizzato per testare l'uguaglianza esatta tra due termini senza unificazione, a differenza dell'operatore '=', che tenta di unificare i termini."
    },
    {
        "question": "L07 D03: Per esprimere la condizione di disuguaglianza si utilizza l'operatore:",
        "image": "",
        "optionA": "\\==",
        "optionB": "!=",
        "optionC": "not",
        "optionD": ">",
        "optionE": "",
        "optionF": "",
        "correct": "optionA",
        "explanation": "L'operatore '\\==' in Prolog è utilizzato per verificare se due termini non sono uguali, ovvero non possono essere unificati."
    },
    {
        "question": "L07 D04: Quale regola bisogna aggiungere alla struttura 'concatena([ | ], L, L')' per ottenere un programma che concatena due liste?",
        "image": "",
        "optionA": "concatena([ ], [ ], [ ])",
        "optionB": "concatena([T | L1], L2, [T | L2])",
        "optionC": "concatena([T | L1], L2, [T | L3]) :- concatena(L1, L2, L3)",
        "optionD": "concatena([T | L1], L2, L3) :- concatena(L1, L2, L3)",
        "optionE": "",
        "optionF": "",
        "correct": "optionC",
        "explanation": "La regola 'concatena([T | L1], L2, [T | L3]) :- concatena(L1, L2, L3)' permette di concatenare due liste in Prolog mediante la ricorsione, inserendo il primo elemento della prima lista nella lista risultante e ricorsivamente concatenando il resto della lista."
    },
    {
        "question": "L07 D05: Si consideri un programma logico contenente la regola 'p(X) :- X = 3*2'. Qual è l'output di Prolog corrispondente al goal 'p(X)'?",
        "image": "",
        "optionA": "true",
        "optionB": "X = 3 * 2",
        "optionC": "false",
        "optionD": "X = 6",
        "optionE": "",
        "optionF": "",
        "correct": "optionB",
        "explanation": "In Prolog, l'uso dell'operatore '=' in questo contesto significa unificazione piuttosto che assegnazione o valutazione. Quindi, l'espressione 'X = 3*2' unifica X con l'espressione aritmetica '3*2', mostrando questo risultato piuttosto che calcolarne il valore."
    },
    {
        "question": "L07 D06: La struttura 'inserisci(X, L, [X | L])' può essere usata:",
        "image": "",
        "optionA": "solo per identificare la testa e la coda di una lista",
        "optionB": "per invertire una lista",
        "optionC": "solo per inserire un elemento in una lista",
        "optionD": "per inserire un elemento in una lista o per identificare la testa e la coda di una lista",
        "optionE": "",
        "optionF": "",
        "correct": "optionD",
        "explanation": "La struttura 'inserisci(X, L, [X | L])' è versatile e può essere usata non solo per inserire un elemento 'X' all'inizio di una lista 'L', risultando nella lista '[X | L]', ma anche per identificare la testa e la coda di una lista durante operazioni come il pattern matching in Prolog."
    },
    {
        "question": "L07 D07: Quale regola bisogna aggiungere alla struttura 'appartenente(X, [X | _])' per ottenere un programma che verifichi l'appartenenza di un elemento ad una lista?",
        "image": "",
        "optionA": "appartenente(X, [_ | C]) :- appartenente(_, C)",
        "optionB": "appartenente(X, [X | C]) :- appartenente(X, C)",
        "optionC": "appartenente(X, X)",
        "optionD": "appartenente(X, [_ | C]) :- appartenente(X, C)",
        "optionE": "",
        "optionF": "",
        "correct": "optionD",
        "explanation": "Per verificare se un elemento 'X' è parte di una lista, è necessario aggiungere una regola che permetta di continuare la ricerca in coda alla lista se il primo elemento non è 'X'. La regola corretta è 'appartenente(X, [_ | C]) :- appartenente(X, C)', dove '_' indica che il primo elemento della lista è ignorato e la ricerca continua con la coda 'C'."
    },
    {
        "question": "L07 D08: Si consideri un programma logico contenente la regola 'p(X) :- X = 3*2'. Qual è l'output di Prolog corrispondente al goal 'p(X)'?",
        "image": "",
        "optionA": "true",
        "optionB": "X = 3 * 2",
        "optionC": "false",
        "optionD": "X = 6",
        "optionE": "",
        "optionF": "",
        "correct": "optionB",
        "explanation": "Nel contesto di Prolog, l'operatore '=' è utilizzato per l'unificazione e non per l'assegnazione aritmetica. Pertanto, 'X = 3*2' non calcola il prodotto ma unifica 'X' con l'espressione '3*2'. Di conseguenza, l'output per il goal 'p(X)' sarà 'X = 3 * 2', mostrando che 'X' è unificato con l'espressione aritmetica non valutata."
    },
    {
        "question": "L08 D01: Quale delle seguenti affermazioni è vera?",
        "image": "",
        "optionA": "La negazione per fallimento permette di inferire che un atomo è falso se esso non è stato dichiarato vero nel programma logico.",
        "optionB": "La negazione per fallimento permette di inferire che un atomo è falso se almeno un goal fallisce.",
        "optionC": "La negazione per fallimento permette di inferire che un atomo è falso se esso non è derivabile dal programma logico.",
        "optionD": "La negazione per fallimento permette di inferire che un atomo è falso se esso è stato dichiarato falso nel programma logico.",
        "optionE": "",
        "optionF": "",
        "correct": "optionC",
        "explanation": "La negazione per fallimento in Prolog si basa sul principio che, se non è possibile derivare (provare) un atomo utilizzando il programma logico, allora si può concludere che l'atomo è falso. Questo segue l'assunzione di mondo chiuso, dove tutto ciò che non può essere dimostrato vero è considerato falso."
    },
    {
        "question": "L08 D02: La negazione per fallimento in Prolog è modellata:",
        "image": "",
        "optionA": "dalla costante 'false'",
        "optionB": "dall'operatore '!='",
        "optionC": "dal predicato 'not'",
        "optionD": "dal predicato 'fail'",
        "optionE": "",
        "optionF": "",
        "correct": "optionC",
        "explanation": "In Prolog, il predicato 'not' viene utilizzato per implementare la negazione per fallimento. Questo predicato tenta di dimostrare l'affermazione passata come argomento e, se fallisce nel derivarla, restituisce 'true', indicando che la negazione dell'affermazione è vera."
    },
    {
        "question": "L08 D03: La risposta di Prolog al goal 'not(false)' è:",
        "image": "",
        "optionA": "un errore",
        "optionB": "not(false)",
        "optionC": "true",
        "optionD": "fail",
        "optionE": "",
        "optionF": "",
        "correct": "optionC",
        "explanation": "Quando Prolog valuta il goal 'not(false)', verifica se 'false' può essere provato. Poiché 'false' non è mai derivabile, 'not(false)' restituisce 'true'. Questo è un esempio diretto di come funziona la negazione per fallimento in Prolog: se l'affermazione non può essere provata, allora la sua negazione è considerata vera."
    },
    {
        "question": "L08 D04: La risposta di Prolog al goal 'not(not(false))' è:",
        "image": "",
        "optionA": "un errore",
        "optionB": "not(false)",
        "optionC": "fail",
        "optionD": "false",
        "optionE": "",
        "optionF": "",
        "correct": "optionD",
        "explanation": "Prolog valuta il goal più interno 'not(false)', che restituisce 'true' (poiché 'false' non è derivabile). Quindi, il goal esterno diventa 'not(true)'. Poiché 'true' è derivabile, 'not(true)' restituisce 'false'. Di conseguenza, l'output finale del goal 'not(not(false))' è 'false'."
    },
    {
        "question": "L08 D05: Si consideri un programma logico contenente la struttura 'uguale(X, X)'. La risposta di Prolog al goal 'uguale([1,2], [1|[2]])' è:",
        "image": "",
        "optionA": "false",
        "optionB": "true",
        "optionC": "X = [1, 2]",
        "optionD": "X = [1|[2]]",
        "optionE": "",
        "optionF": "",
        "correct": "optionB",
        "explanation": "In Prolog, '[1|[2]]' è una rappresentazione alternativa della lista '[1,2]'. Entrambe le notazioni rappresentano la stessa lista. Il predicato 'uguale(X, X)' verifica se i due argomenti sono uguali. Poiché '[1,2]' e '[1|[2]]' rappresentano la stessa lista, il goal 'uguale([1,2], [1|[2]])' restituisce 'true'."
    },
    {
        "question": "L08 D06: Si consideri un programma logico contenente la struttura 'uguale(X, X)'. La risposta di Prolog al goal 'uguale([1], [1|[]])' è:",
        "image": "",
        "optionA": "true",
        "optionB": "X = [1]",
        "optionC": "false",
        "optionD": "X = [1|[]]",
        "optionE": "",
        "optionF": "",
        "correct": "optionA",
        "explanation": "Similmente alla domanda precedente, '[1|[]]' è una rappresentazione alternativa della lista '[1]'. Entrambe le notazioni rappresentano la stessa lista. Il predicato 'uguale(X, X)' verifica se i due argomenti sono uguali. Poiché '[1]' e '[1|[]]' rappresentano la stessa lista, il goal 'uguale([1], [1|[]])' restituisce 'true'."
    },
    {
        "question": "L08 D07: Si consideri il programma logico riportato in figura. La risposta di Prolog al goal 'not(mortale(aristotele))' è:",
        "image": "",
        "optionA": "false",
        "optionB": "true",
        "optionC": "fail",
        "optionD": "Restituisce un errore",
        "optionE": "",
        "optionF": "",
        "correct": "optionB",
        "explanation": "Nel programma logico fornito, il fatto 'uomo(socrate)' è dichiarato, ma non c'è alcuna informazione su 'aristotele'. La regola 'mortale(X)' è vera per tutti gli 'X' che soddisfano 'uomo(X)'. Poiché 'aristotele' non è dichiarato come 'uomo', il goal 'mortale(aristotele)' non può essere provato. Di conseguenza, la negazione 'not(mortale(aristotele))' risulta vera, quindi la risposta corretta è 'true'."
    },
    {
        "question": "L08 D08: Si consideri il programma logico riportato in figura. La risposta di Prolog al goal 'c(a, [a], A)' è:",
        "image": "",
        "optionA": "fail",
        "optionB": "A = a",
        "optionC": "true",
        "optionD": "A = 1",
        "optionE": "",
        "optionF": "",
        "correct": "optionD",
        "explanation": "Nel programma logico fornito, il predicato 'c' conta il numero di occorrenze di un elemento in una lista. Il primo fatto dichiara che per una lista vuota, il conteggio è 0. La seconda regola incrementa il conteggio quando l'elemento 'X' è trovato nella testa della lista '[X | L]'. La terza regola procede ricorsivamente sulla coda della lista '[Y | L]' senza incrementare il conteggio se la testa non è 'X'. Quando viene eseguito il goal 'c(a, [a], A)', la seconda regola viene applicata poiché 'a' è la testa della lista '[a]'. Quindi, 'c(a, [], S)' viene chiamato, e secondo il primo fatto, 'S = 0'. Il conteggio viene quindi incrementato: 'C is 0 + 1', quindi 'C = 1'. Pertanto, la risposta corretta è 'A = 1'."
    },
    {
        "question": "L09 D01: Si consideri il programma logico riportato in figura. Qual è la funzione svolta da 't'?",
        "image": "",
        "optionA": "verifica se il numero di elementi di una lista è maggiore di una certa soglia",
        "optionB": "verifica se tutti gli elementi di una lista sono maggiori di certa una soglia",
        "optionC": "verifica se almeno un elemento di una lista è maggiore di una certa soglia",
        "optionD": "verifica se tutti gli elementi di una lista sono nulli",
        "optionE": "",
        "optionF": "",
        "correct": "optionB",
        "explanation": "Il programma verifica se tutti gli elementi di una lista sono maggiori di una certa soglia 'S'. La regola base 't(_, []) :- !.' indica che una lista vuota è sempre considerata vera. La regola ricorsiva 't(S, [T | C]) :- T > S, t(S, C).' verifica se la testa della lista 'T' è maggiore di 'S' e, se vero, procede ricorsivamente sulla coda della lista 'C'."
    },
    {
        "question": "L09 D02: Si consideri il programma logico riportato in figura. Qual è la risposta di Prolog al goal 'q(b)'?",
        "image": "",
        "optionA": "un errore",
        "optionB": "false",
        "optionC": "true",
        "optionD": "fail",
        "optionE": "",
        "optionF": "",
        "correct": "optionB",
        "explanation": "Quando si esegue il goal 'q(b)', Prolog non trova nessun fatto o regola che soddisfa 'q(b)', quindi il risultato è 'false'. Il predicato 'q(b)' non è definito nel programma, solo 'q(a)' è definito."
    },
    {
        "question": "L09 D03: Si consideri il programma logico riportato in figura. Qual è la risposta di Prolog al goal 'q(a)'?",
        "image": "",
        "optionA": "un errore",
        "optionB": "true",
        "optionC": "false",
        "optionD": "fail",
        "optionE": "",
        "optionF": "",
        "correct": "optionB",
        "explanation": "Quando si esegue il goal 'q(a)', Prolog trova il fatto 'q(a)', quindi il risultato è 'true'. Il fatto 'q(a)' è definito direttamente nel programma, quindi Prolog può risolverlo positivamente."
    },
    {
        "question": "L09 D04: La risposta di Prolog al goal 'fail' è:",
        "image": "",
        "optionA": "false",
        "optionB": "fail",
        "optionC": "true",
        "optionD": "un errore",
        "optionE": "",
        "optionF": "",
        "correct": "optionA",
        "explanation": "Il predicato 'fail' in Prolog è progettato per forzare il fallimento del goal in cui appare. Quando Prolog incontra 'fail', termina immediatamente l'esecuzione del goal corrente e restituisce 'false', indicando che il goal non può essere soddisfatto."
    },
    {
        "question": "L09 D05: Cosa restituisce la valutazione del 'fail'?",
        "image": "",
        "optionA": "true",
        "optionB": "un errore",
        "optionC": "fail",
        "optionD": "false",
        "optionE": "",
        "optionF": "",
        "correct": "optionD",
        "explanation": "La valutazione del predicato 'fail' restituisce sempre 'false'. Questo predicato è utilizzato per interrompere l'esecuzione corrente e indicare che il goal non può essere soddisfatto."
    },
    {
        "question": "L09 D06: Cosa restituisce la valutazione del 'cut'?",
        "image": "",
        "optionA": "true",
        "optionB": "fail",
        "optionC": "un errore",
        "optionD": "false",
        "optionE": "",
        "optionF": "",
        "correct": "optionA",
        "explanation": "Il predicato 'cut' (rappresentato da '!') in Prolog serve a controllare il processo di backtracking, tagliando via tutte le alternative di scelta che sono state generate prima del 'cut'. La valutazione di 'cut' restituisce sempre 'true'."
    },
    {
        "question": "L09 D07: La risposta di Prolog al goal 'not(fail)' è:",
        "image": "",
        "optionA": "true",
        "optionB": "un errore",
        "optionC": "false",
        "optionD": "fail",
        "optionE": "",
        "optionF": "",
        "correct": "optionA",
        "explanation": "Quando viene eseguito il goal 'not(fail)', Prolog verifica se il goal 'fail' può essere provato. Poiché 'fail' fallisce sempre, 'not(fail)' risulta vero. Quindi, la risposta al goal 'not(fail)' è 'true'."
    },
    {
        "question": "L09 D08: Quali delle seguenti affermazioni è vera?",
        "image": "",
        "optionA": "Il cut quando valutato restituisce un errore.",
        "optionB": "Il cut permette di trovare sempre al più una soluzione per un goal",
        "optionC": "Il cut riduce lo spazio di ricerca delle soluzioni di un goal",
        "optionD": "Il cut impedisce a Prolog di trovare soluzioni per un goal",
        "optionE": "",
        "optionF": "",
        "correct": "optionC",
        "explanation": "Il predicato 'cut' ('!') in Prolog serve a controllare il processo di backtracking, tagliando via tutte le alternative di scelta che sono state generate prima del 'cut'. Questo riduce lo spazio di ricerca delle soluzioni di un goal, limitando Prolog a considerare solo il ramo di esecuzione corrente e ignorando tutte le altre possibili soluzioni alternative."
    }
]